#!/usr/bin/env python
# coding: utf-8

# 1. Построение аналитической модели полета тела, брошенного под 
# углом к горизонту без учёта сопротивления воздуха.
import matplotlib
matplotlib.use('Agg')  # Используем Agg бэкенд
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import ode


#функция для восстановления параметров регрессии a = f (v)
def my_koeff_a (v, a):
    return v*a[1] + a[0]

#функция для восстановления параметров регрессии b = f (v**2)
def my_koeff_b (v, b):
    return v**2*b[1] + b[0]


#Численное решение уравнений

# функция правых частей системы ОДУ
def f(t, vect, k):
    #получение переменных из аргумента
    Vy, Vx, Y, X = vect
    V_0, alpha_0, a_regr,  b_regr = k
    V_mag = np.sqrt(Vx**2 + Vy**2) #Модуль вектора скорости
    #рассчитаем значения коэффициента a c помощью функции
    a = my_koeff_a(V_mag*V_0, a_regr)
    #рассчитаем значения коэффициента b c помощью функции
    b = my_koeff_b(V_mag*V_0, b_regr)
    #расчет вектора - столбца правой части и вывод результата
    return [-np.sin(alpha_0)*(1 + (a + b*V_mag)*Vy), -np.sin(alpha_0)*Vx*(a + b*V_mag),
            2*Vy/np.sin(alpha_0), Vx/(2*np.cos(alpha_0))]

# функция - обработчик шага 
def fout(t, vect):
    global Dist, H_max, T_flight, T_att, Vy_old
    #получение переменных из аргумента
    Vy, Vx, y, x = vect

    if Vy*Vy_old <= 0:  # достигнута точка максимума
        H_max = y
        T_att = t
    #Остановка вычисления если скорость отрицательна и координата y меньше или равна 0
    if Vy < 0 and y <= 0.0: # тело достигло поверхности
        Dist = x
        T_flight = t
        return -1 #функция возвращает -1 для остановки вычислений
    #дописываем текущее значенике ввремени в список значений времени 
    ts.append(t)
    #дописываем текущее значенике проекций скоростей и координат в список результатов
    ys.append(list(vect.copy()))
    Vy_old = Vy
    #display(ts)

    
def my_solver(V_0, angle_0, a_regr, b_regr):

    #Задаем предельно значение времени расчета
    tmax = 2
    #Выполняем настройку решателя
    ODE = ode(f)
    #Используем метод Рунге-Кутты 5 порядка. Максимальный шаг интегрирования 0,01 с
    ODE.set_integrator('dopri5', max_step = 0.005)
    ODE.set_f_params([V_0, alpha_0, a_regr, b_regr]) #передача параметров в функцию
    #Устанавливаем параметры управления вызова интегратора на каждом успешном шаге интегрирования
    ODE.set_solout(fout)
    #Задаем вектор начальных условий
    y0 = [np.sin(alpha_0), np.cos(alpha_0), y_0, x_0]
    ODE.set_initial_value(y0, t_0) # задание начальных значений
    ODE.integrate(tmax)      # решение ОДУ
    return np.array(ys)  
 

#начальные условия
V_0 =  50  #начальная скорость, м/с 
angle_0 = 30 #начальный угол навеса, град 
x_0 = 0 #начальная координата по оси абсцисс
y_0 = 0 #начальная координата по оси ординат
t_0 = 0 #начальное значение времени
g = 9.8  #м/с**2 ускорение свободного падения

alpha_0 = np.radians(angle_0)  # перевод градусов в радианы
H = (V_0*np.sin(alpha_0))**2/(2*g)  # расчет максимальной высоты подъема
L = V_0**2*np.sin(2*alpha_0)/g      # расчет длины броска
T = 2*V_0*np.sin(alpha_0)/g         #расчет длительности полета 
#задание пустых списков значений времени и результатов расчета
ts = []
ys = []
#скорость на шаге k-1 (предыдущий шаг)
Vy_old = 0
#запуск солвера для решения задачи при отсутствеии сопротивления воздуха
Y = my_solver(V_0, angle_0, [0,0], [0,0]) 
#получение значений координат и проекций скоростей из результатов решения 
#дифференциального уравнения при отсутствии сопротивления воздуха
x = Y[:,3]  #координата Х
y = Y[:,2]  #координата Y
Vy = Y[:,0] #проекция вектора сокорости на ось Y
Vx = Y[:,1]  #проекция вектора сокорости на ось X
print("Done")
#построение графика
fig = plt.figure(facecolor='white')
plt.plot(x, y)
plt.title("Траектория полета пули без учета сопротивления воздуха", fontsize = 12)
plt.ylabel("y, о.е.")
plt.xlabel("x, о.е.")
plt.ylim([0, 1.2])
plt.grid(True)

#plt.show() # display
plt.savefig('/app/myplot.png')





